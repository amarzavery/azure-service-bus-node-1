import { EventEmitter } from 'events';

import { BrokeredMessage } from './brokeredMessage';

/**
 * The mode in which messages should be received
 */
export enum ReceiveMode {
    /**
     * Peek the message and lock it until it is settled or times out
     * @type {Number}
     */
    PeekLock = 1,

    /**
     * Remove the message from the service bus upon delivery
     * @type {Number}
     */
    ReceiveAndDelete = 2
}

/**
 * The state of the processing that a message is in
 */
export enum ProcessingState {
    /**
     * The message is currently being processed by the recipient.
     * @type {Number}
     */
    Active = 1,

    /**
     * The recipient has asked to settle the message, but it has not been
     * settled yet. The message cannot be altered at this point.
     * @type {Number}
     */
    Settling = 2,

    /**
     * The recipient has settled the message. The message cannot be altered at
     * this point.
     * @type {Number}
     */
    Settled = 3,

    /**
     * There is no processing state for this message. It was generated by the
     * user.
     * @type {Number}
     */
    None = 4,

    /**
     * Settling this message failed because of an underlying issue. The message
     * cannot be re-acknowledged at this point
     * @type {Number}
     */
    SettleFailed = 5,
}

/**
 * Options to the onMessage() function
 */
export interface OnMessageOptions {
    /**
     * The mode in which messages should be received. Default: ReceiveMode.PeekLock
     * @type {ReceiveMode}
     */
    receiveMode?: ReceiveMode;

    /**
     * Whether complete() should be called on a message once its handler has
     * completed execution. Default: true
     * @type {boolean}
     */
    autoComplete?: boolean;

    /**
     * The time period (in milliseconds) during which peek locked messages
     * should have their lock renewed. After this time period, the lock will
     * expire if the message is not settled. Default: 300000 (5 minutes)
     * @type {number}
     */
    autoRenewTimeout?: number;

    /**
     * The maximum number of messages that should be processed concurrently while
     * in peek lock mode. Once this limit has been reached, more messages will
     * not be received until messages currently being processed have been settled.
     * Default: 1
     * @type {number}
     */
    maxConcurrentCalls?: number;
}

/**
 * Handle for sending to and receiving messages from a service bus queue
 */

export namespace Queue {
    export const SENDER_DETACHED = 'senderDetached';
    export const SENDER_REATTACHED = 'senderReattached';
}

export interface Queue extends EventEmitter {
    queueName: string;
    canSend(): Promise<boolean>;
    send<T>(message: BrokeredMessage<T>, timeoutMs?: number): Promise<void>;
    onMessage<T>(listener: (message: BrokeredMessage<T>) => void | Promise<void>, options?: OnMessageOptions): MessageListener;
    onDeadLetteredMessage<T>(listener: (message: BrokeredMessage<T>) => void | Promise<void>, options?: OnMessageOptions): MessageListener;
    receive<T>(timeoutMs?: number): Promise<BrokeredMessage<T>>;
    receiveBatch<T>(messageCount: number, timeoutMs?: number): Promise<BrokeredMessage<T>[]>;
    disposeSender(): Promise<void>;
}

/**
 * Handle for sending to and receiving messages from a service bus topic
 */
export namespace Topic {
    export const SENDER_DETACHED = 'senderDetached';
    export const SENDER_REATTACHED = 'senderReattached';
}

export interface Topic extends EventEmitter {
    topicName: string;
    canSend(): Promise<boolean>;
    send<T>(message: BrokeredMessage<T>, timeoutMs?: number): Promise<void>;
    onMessage<T>(subscriptionName: string, listener: (message: BrokeredMessage<T>) => void | Promise<void>, options?: OnMessageOptions): MessageListener;
    onDeadLetteredMessage<T>(subscriptionName: string, listener: (message: BrokeredMessage<T>) => void | Promise<void>, options?: OnMessageOptions): MessageListener;
    receive<T>(subscriptionName: string, timeoutMs?: number): Promise<BrokeredMessage<T>>;
    receiveBatch<T>(subscriptionName: string, messageCount: number, timeoutMs?: number): Promise<BrokeredMessage<T>[]>;
    disposeSender(): Promise<void>;
}

export interface MessageListener extends EventEmitter {
    on(type: 'detached', listener: (info: any) => void): this;
    on(type: 'attached', listener: () => void): this;
    on(type: 'receiverError', listener: (err: Error) => void): this;
    on(type: 'managementLinkAttached', listener: (name: string, path: string, isSender: boolean) => void): this;
    on(type: 'managementLinkDetached', listener: (name: string, path: string, isSender: boolean, info: any) => void): this;
    on(type: string, listener: (...args: any[]) => void): this;

    isListening: boolean;
    pendingSettleCount: number;
    dispose(): void;
}

export type LogFn = (namespace: string, message: string) => void;
